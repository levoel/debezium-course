---
import BaseLayout from '../layouts/BaseLayout.astro';
import { GlossaryTerm } from '../components/GlossaryTerm';

const basePath = import.meta.env.BASE_URL;

// Define categories for navigation
const categories = [
  { id: 'postgresql', name: 'PostgreSQL' },
  { id: 'mysql', name: 'MySQL' },
  { id: 'kafka', name: 'Kafka' },
  { id: 'debezium', name: 'Debezium' },
  { id: 'general', name: 'General' },
];

// Category icons as inline SVG (database-style icons)
const categoryIcons: Record<string, string> = {
  postgresql: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><ellipse cx="12" cy="8" rx="7" ry="4" stroke-linecap="round" stroke-linejoin="round"/><path stroke-linecap="round" stroke-linejoin="round" d="M5 8v8c0 2.21 3.134 4 7 4s7-1.79 7-4V8"/><path stroke-linecap="round" stroke-linejoin="round" d="M5 12c0 2.21 3.134 4 7 4s7-1.79 7-4"/></svg>',
  mysql: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><ellipse cx="12" cy="8" rx="7" ry="4" stroke-linecap="round" stroke-linejoin="round"/><path stroke-linecap="round" stroke-linejoin="round" d="M5 8v8c0 2.21 3.134 4 7 4s7-1.79 7-4V8"/><path stroke-linecap="round" stroke-linejoin="round" d="M9 11v6M15 11v6"/></svg>',
  kafka: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M15.59 14.37a6 6 0 01-5.84 7.38v-4.8m5.84-2.58a14.98 14.98 0 006.16-12.12A14.98 14.98 0 009.631 8.41m5.96 5.96a14.926 14.926 0 01-5.841 2.58m-.119-8.54a6 6 0 00-7.381 5.84h4.8m2.581-5.84a14.927 14.927 0 00-2.58 5.84m2.699 2.7c-.103.021-.207.041-.311.06a15.09 15.09 0 01-2.448-2.448 14.9 14.9 0 01.06-.312m-2.24 2.39a4.493 4.493 0 00-1.757 4.306 4.493 4.493 0 004.306-1.758M16.5 9a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0z"/></svg>',
  debezium: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"/></svg>',
  general: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M12 21v-8.25M15.75 21v-8.25M8.25 21v-8.25M3 9l9-6 9 6m-1.5 12V10.332A48.36 48.36 0 0012 9.75c-2.551 0-5.056.2-7.5.582V21M3 21h18M12 6.75h.008v.008H12V6.75z"/></svg>',
};
---

<BaseLayout
  title="Глоссарий терминов CDC"
  description="Справочник терминов Change Data Capture, Debezium, PostgreSQL, MySQL и Kafka с примерами и ссылками на уроки"
>
  <div class="prose prose-invert max-w-none">
    <!-- Page Header -->
    <div class="mb-8">
      <h1 class="text-4xl font-bold text-gray-100 mb-3 flex items-center gap-3">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-10 h-10">
          <path stroke-linecap="round" stroke-linejoin="round" d="M12 21v-8.25M15.75 21v-8.25M8.25 21v-8.25M3 9l9-6 9 6m-1.5 12V10.332A48.36 48.36 0 0012 9.75c-2.551 0-5.056.2-7.5.582V21M3 21h18M12 6.75h.008v.008H12V6.75z" />
        </svg>
        Глоссарий терминов CDC
      </h1>
      <p class="text-gray-300 text-lg leading-relaxed">
        Справочник ключевых терминов Change Data Capture. Каждый термин содержит определение,
        практический пример и ссылки на уроки курса для углубленного изучения.
      </p>
    </div>

    <!-- Category Navigation -->
    <div class="mb-10" data-pagefind-ignore>
      <div class="glass-panel p-6">
        <h2 class="text-lg font-semibold text-gray-100 mb-4 mt-0">Навигация по категориям</h2>
        <div class="flex flex-wrap gap-3">
          {categories.map((category) => (
            <a
              href={`#${category.id}`}
              class="glass-button inline-flex items-center gap-2 px-4 py-2.5 text-sm font-medium text-gray-100 hover:text-white"
            >
              <span set:html={categoryIcons[category.id]} />
              {category.name}
            </a>
          ))}
        </div>
        <p class="text-xs text-gray-400 mt-4 mb-0">
          <strong>Совет:</strong> Используйте Cmd+K (Ctrl+K) для быстрого поиска по терминам
        </p>
      </div>
    </div>

    <!-- Glossary Content - Pagefind indexed -->
    <div data-pagefind-body>

      <!-- PostgreSQL Section -->
      <section id="postgresql" class="mb-12 scroll-mt-24">
        <h2 class="text-3xl font-bold text-gray-100 mb-6 flex items-center gap-3 border-b border-white/10 pb-3">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8">
            <ellipse cx="12" cy="8" rx="7" ry="4" stroke-linecap="round" stroke-linejoin="round"/>
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 8v8c0 2.21 3.134 4 7 4s7-1.79 7-4V8"/>
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 12c0 2.21 3.134 4 7 4s7-1.79 7-4"/>
          </svg>
          PostgreSQL
        </h2>

        <GlossaryTerm
          term="WAL"
          termEn="Write-Ahead Log"
          definition="Журнал упреждающей записи — механизм ACID-гарантий в PostgreSQL. Все изменения сначала записываются в WAL, затем применяются к данным. Debezium читает WAL через логическую репликацию для захвата изменений без нагрузки на production базу."
          example={`-- Просмотр текущей позиции WAL
SELECT pg_current_wal_lsn();
-- Результат: 0/16B9F08

-- Размер несинхронизированного WAL
SELECT pg_wal_lsn_diff(
  pg_current_wal_lsn(),
  confirmed_flush_lsn
) FROM pg_replication_slots
WHERE slot_name = 'debezium';`}
          relatedLessons={[
            { title: "CDC Fundamentals", slug: "01-module-1/01-cdc-fundamentals" },
            { title: "WAL Configuration", slug: "02-module-2/03-wal-configuration-tuning" },
            { title: "Replication Slots", slug: "02-module-2/02-replication-slots-lifecycle" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="LSN"
          termEn="Log Sequence Number"
          definition="Уникальный идентификатор позиции в WAL. Используется для отслеживания прогресса репликации и определения лага. Формат: 16/3E8A0F00 где первая часть — номер файла WAL, вторая — смещение внутри файла."
          example={`-- Текущий LSN
SELECT pg_current_wal_lsn();
-- Результат: 0/16B9F08

-- LSN в числовом формате (для расчёта лага)
SELECT pg_wal_lsn_diff('0/16B9F08', '0/16B9E00');
-- Результат: 264 байта`}
          relatedLessons={[
            { title: "Lag Detection", slug: "04-module-4/04-lag-detection-alerting" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Replication Slot"
          termEn="Слот репликации"
          definition="Механизм PostgreSQL для отслеживания прогресса логической репликации. Слот гарантирует, что WAL-сегменты не будут удалены до тех пор, пока Debezium их не прочитает. КРИТИЧНО: неиспользуемые слоты приводят к переполнению диска."
          example={`-- Просмотр активных слотов
SELECT slot_name, active, restart_lsn,
       confirmed_flush_lsn
FROM pg_replication_slots;

-- Создание слота для Debezium
SELECT pg_create_logical_replication_slot(
  'debezium',
  'pgoutput'
);

-- Удаление слота (потеря позиции!)
SELECT pg_drop_replication_slot('debezium');`}
          relatedLessons={[
            { title: "Replication Slots Lifecycle", slug: "02-module-2/02-replication-slots-lifecycle" },
            { title: "WAL Bloat Prevention", slug: "02-module-2/04-wal-bloat-prevention" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Logical Decoding"
          termEn="Логическое декодирование"
          definition="Механизм PostgreSQL для извлечения изменений из WAL в читаемом формате. Logical decoding преобразует низкоуровневые WAL-записи в структурированные события (INSERT, UPDATE, DELETE) с именами таблиц и значениями полей. Debezium использует logical decoding через плагин pgoutput."
          example={`-- Проверка доступных плагинов
SELECT * FROM pg_available_extensions
WHERE name = 'pgoutput';

-- Создание слота с плагином декодирования
SELECT pg_create_logical_replication_slot(
  'test_slot',
  'pgoutput'
);

-- Чтение изменений (для тестирования)
SELECT * FROM pg_logical_slot_peek_changes(
  'test_slot',
  NULL,
  NULL
);`}
          relatedLessons={[
            { title: "CDC Fundamentals", slug: "01-module-1/01-cdc-fundamentals" },
            { title: "WAL Configuration", slug: "02-module-2/03-wal-configuration-tuning" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Publication"
          termEn="Публикация"
          definition="Объект PostgreSQL, который определяет набор таблиц для логической репликации. Publication указывает, какие таблицы и операции (INSERT/UPDATE/DELETE) должны реплицироваться. Debezium автоматически создаёт publication для указанных таблиц."
          example={`-- Создание publication для всех таблиц
CREATE PUBLICATION dbz_publication
FOR ALL TABLES;

-- Publication для конкретных таблиц
CREATE PUBLICATION dbz_publication
FOR TABLE customers, orders;

-- Только INSERT и UPDATE (без DELETE)
CREATE PUBLICATION dbz_publication
FOR TABLE customers
WITH (publish = 'insert, update');

-- Просмотр publications
SELECT * FROM pg_publication;`}
          relatedLessons={[
            { title: "First Connector", slug: "01-module-1/04-first-connector" },
            { title: "Connector Configuration", slug: "02-module-2/01-connector-configuration" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="pgoutput"
          termEn="Плагин pgoutput"
          definition="Встроенный плагин PostgreSQL для logical decoding (с версии 10+). pgoutput — нативный плагин, который не требует отдельной установки, в отличие от wal2json или decoderbufs. Debezium по умолчанию использует pgoutput для максимальной совместимости."
          example={`-- PostgreSQL config для pgoutput
wal_level = logical
max_replication_slots = 4
max_wal_senders = 4

-- Connector config
{
  "plugin.name": "pgoutput",
  "publication.name": "dbz_publication"
}

-- Проверка использования pgoutput
SELECT slot_name, plugin
FROM pg_replication_slots;
-- Результат: debezium | pgoutput`}
          relatedLessons={[
            { title: "WAL Configuration", slug: "02-module-2/03-wal-configuration-tuning" },
            { title: "Connector Configuration", slug: "02-module-2/01-connector-configuration" }
          ]}
          basePath={basePath}
          client:load
        />
      </section>

      <!-- MySQL Section -->
      <section id="mysql" class="mb-12 scroll-mt-24">
        <h2 class="text-3xl font-bold text-gray-100 mb-6 flex items-center gap-3 border-b border-white/10 pb-3">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8">
            <ellipse cx="12" cy="8" rx="7" ry="4" stroke-linecap="round" stroke-linejoin="round"/>
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 8v8c0 2.21 3.134 4 7 4s7-1.79 7-4V8"/>
            <path stroke-linecap="round" stroke-linejoin="round" d="M9 11v6M15 11v6"/>
          </svg>
          MySQL
        </h2>

        <GlossaryTerm
          term="Binlog"
          termEn="Binary Log"
          definition="Бинарный лог MySQL, который записывает все изменения данных для репликации и восстановления. Debezium читает binlog для захвата CDC событий. Формат может быть STATEMENT, ROW или MIXED (только ROW поддерживается Debezium)."
          example={`-- Проверка включения binlog
SHOW VARIABLES LIKE 'log_bin';

-- Текущая позиция binlog
SHOW MASTER STATUS;

-- Список binlog файлов
SHOW BINARY LOGS;

-- Установка retention периода
SET GLOBAL expire_logs_days = 7;
SET GLOBAL binlog_expire_logs_seconds = 604800;`}
          relatedLessons={[
            { title: "MySQL Binlog Fundamentals", slug: "07-module-7/01-binlog-fundamentals" },
            { title: "Binlog Retention", slug: "03-module-3/03-binlog-retention-heartbeat" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="GTID"
          termEn="Global Transaction Identifier"
          definition="Глобальный идентификатор транзакции в MySQL. GTID упрощает репликацию и восстановление, делая позицию в binlog независимой от конкретного файла. Формат: server_uuid:transaction_id (например, 3E11FA47-71CA-11E1-9E33-C80AA9429562:23)."
          example={`-- Проверка включения GTID
SHOW VARIABLES LIKE 'gtid_mode';

-- Текущий executed GTID set
SHOW MASTER STATUS;

-- GTID purged (удаленные binlog)
SHOW GLOBAL VARIABLES LIKE 'gtid_purged';`}
          relatedLessons={[
            { title: "MySQL Connector Setup", slug: "07-module-7/02-connector-setup" },
            { title: "Aurora MySQL Specifics", slug: "07-module-7/04-aurora-specifics" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="server_id"
          termEn="Идентификатор сервера MySQL"
          definition="Уникальный идентификатор MySQL сервера в топологии репликации. Каждый сервер (master, slave, Debezium) должен иметь уникальный server_id. Debezium использует server_id для идентификации себя как replica и для чтения binlog."
          example={`-- Просмотр текущего server_id
SHOW VARIABLES LIKE 'server_id';

-- my.cnf конфигурация
[mysqld]
server-id = 1
log-bin = mysql-bin
binlog_format = ROW

-- Connector config
{
  "database.server.id": "184054",
  "database.hostname": "mysql",
  "database.port": "3306"
}`}
          relatedLessons={[
            { title: "MySQL Binlog Fundamentals", slug: "07-module-7/01-binlog-fundamentals" },
            { title: "Connector Setup", slug: "07-module-7/02-connector-setup" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="binlog_format"
          termEn="Формат binlog"
          definition="Формат записи изменений в binlog. Может быть STATEMENT (SQL-запросы), ROW (изменённые строки) или MIXED. Debezium поддерживает ТОЛЬКО binlog_format=ROW, так как только ROW-формат содержит полные значения полей до и после изменения."
          example={`-- Проверка формата binlog
SHOW VARIABLES LIKE 'binlog_format';

-- my.cnf конфигурация (обязательно для Debezium)
[mysqld]
binlog_format = ROW
binlog_row_image = FULL

-- Изменение в runtime (требует SUPER привилегии)
SET GLOBAL binlog_format = 'ROW';`}
          relatedLessons={[
            { title: "MySQL Binlog Fundamentals", slug: "07-module-7/01-binlog-fundamentals" },
            { title: "Connector Setup", slug: "07-module-7/02-connector-setup" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="binlog_row_image"
          termEn="Объём данных в ROW событии"
          definition="Параметр MySQL, определяющий, какие колонки записываются в binlog при UPDATE. Может быть FULL (все колонки), MINIMAL (только PK и изменённые), NOBLOB (без BLOB/TEXT). Debezium требует FULL для получения complete before/after state."
          example={`-- Проверка binlog_row_image
SHOW VARIABLES LIKE 'binlog_row_image';

-- my.cnf конфигурация
[mysqld]
binlog_row_image = FULL

-- MINIMAL (экономит место, но Debezium не увидит неизменённые поля)
binlog_row_image = MINIMAL

-- Пример события с FULL
UPDATE users SET email = 'new@example.com' WHERE id = 1;
-- Binlog содержит: id, name, email (до и после)`}
          relatedLessons={[
            { title: "MySQL Binlog Fundamentals", slug: "07-module-7/01-binlog-fundamentals" },
            { title: "Event Structure", slug: "05-module-5/01-event-structure" }
          ]}
          basePath={basePath}
          client:load
        />
      </section>

      <!-- Kafka Section -->
      <section id="kafka" class="mb-12 scroll-mt-24">
        <h2 class="text-3xl font-bold text-gray-100 mb-6 flex items-center gap-3 border-b border-white/10 pb-3">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8">
            <path stroke-linecap="round" stroke-linejoin="round" d="M15.59 14.37a6 6 0 01-5.84 7.38v-4.8m5.84-2.58a14.98 14.98 0 006.16-12.12A14.98 14.98 0 009.631 8.41m5.96 5.96a14.926 14.926 0 01-5.841 2.58m-.119-8.54a6 6 0 00-7.381 5.84h4.8m2.581-5.84a14.927 14.927 0 00-2.58 5.84m2.699 2.7c-.103.021-.207.041-.311.06a15.09 15.09 0 01-2.448-2.448 14.9 14.9 0 01.06-.312m-2.24 2.39a4.493 4.493 0 00-1.757 4.306 4.493 4.493 0 004.306-1.758M16.5 9a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0z"/>
          </svg>
          Kafka
        </h2>

        <GlossaryTerm
          term="Topic"
          termEn="Топик Kafka"
          definition="Категория или поток сообщений в Kafka. Debezium создаёт отдельный топик для каждой таблицы (по умолчанию формат: server_name.schema_name.table_name). Топики делятся на партиции для параллельной обработки."
          example={`# Список топиков Debezium
kafka-topics --list --bootstrap-server localhost:9092 \\
  | grep dbserver1

# Информация о топике
kafka-topics --describe \\
  --topic dbserver1.inventory.customers \\
  --bootstrap-server localhost:9092

# Чтение сообщений из топика
kafka-console-consumer \\
  --bootstrap-server localhost:9092 \\
  --topic dbserver1.inventory.customers \\
  --from-beginning`}
          relatedLessons={[
            { title: "Kafka Fundamentals", slug: "01-module-1/02-kafka-fundamentals" },
            { title: "Topic Configuration", slug: "04-module-4/01-topic-configuration" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Offset"
          termEn="Смещение Kafka"
          definition="Уникальный последовательный идентификатор сообщения внутри партиции. Consumer отслеживает offset для управления позицией чтения. Debezium хранит свой offset отдельно для отслеживания прогресса репликации из базы данных."
          example={`# Просмотр текущих offset consumer group
kafka-consumer-groups --describe \\
  --group connect-cluster \\
  --bootstrap-server localhost:9092

# Сброс offset для повторного чтения
kafka-consumer-groups --reset-offsets \\
  --group connect-cluster \\
  --topic dbserver1.inventory.customers \\
  --to-earliest --execute`}
          relatedLessons={[
            { title: "Offset Management", slug: "03-module-3/05-offset-management" },
            { title: "Recovery Procedures", slug: "03-module-3/13-recovery-procedures" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Partition"
          termEn="Партиция Kafka"
          definition="Физическое разделение топика для параллельной обработки и масштабирования. Каждая партиция — упорядоченный лог сообщений. Debezium по умолчанию использует primary key таблицы как ключ партиционирования для сохранения порядка событий одной записи."
          example={`# Создание топика с 3 партициями
kafka-topics --create \\
  --topic dbserver1.inventory.orders \\
  --partitions 3 \\
  --replication-factor 2 \\
  --bootstrap-server localhost:9092

# Просмотр партиций топика
kafka-topics --describe \\
  --topic dbserver1.inventory.orders \\
  --bootstrap-server localhost:9092

# Connector config - партиционирование по user_id
{
  "transforms": "partitionByUser",
  "transforms.partitionByUser.type":
    "org.apache.kafka.connect.transforms.ValueToKey",
  "transforms.partitionByUser.fields": "user_id"
}`}
          relatedLessons={[
            { title: "Kafka Fundamentals", slug: "01-module-1/02-kafka-fundamentals" },
            { title: "Topic Configuration", slug: "04-module-4/01-topic-configuration" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Consumer Group"
          termEn="Группа потребителей"
          definition="Группа Kafka consumers, которые совместно читают сообщения из топика. Каждая партиция читается только одним consumer в группе, что обеспечивает параллельную обработку без дублирования. Kafka Connect создаёт consumer group для каждого коннектора."
          example={`# Список consumer groups
kafka-consumer-groups --list \\
  --bootstrap-server localhost:9092

# Детали группы (offset, lag)
kafka-consumer-groups --describe \\
  --group connect-debezium-postgres \\
  --bootstrap-server localhost:9092

# Результат:
# GROUP       TOPIC         PARTITION  OFFSET  LAG
# connect-... customers     0          1523    0
# connect-... customers     1          1498    0
# connect-... orders        0          5832    12`}
          relatedLessons={[
            { title: "Kafka Fundamentals", slug: "01-module-1/02-kafka-fundamentals" },
            { title: "Lag Detection", slug: "04-module-4/04-lag-detection-alerting" }
          ]}
          basePath={basePath}
          client:load
        />
      </section>

      <!-- Debezium Section -->
      <section id="debezium" class="mb-12 scroll-mt-24">
        <h2 class="text-3xl font-bold text-gray-100 mb-6 flex items-center gap-3 border-b border-white/10 pb-3">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8">
            <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"/>
          </svg>
          Debezium
        </h2>

        <GlossaryTerm
          term="Snapshot"
          termEn="Снимок данных"
          definition="Начальная полная копия данных из таблицы перед началом потоковой репликации. Debezium делает consistent snapshot без блокировки записей (через MVCC в PostgreSQL или с использованием LOCK TABLES в MySQL)."
          example={`// Connector config - snapshot mode
{
  "snapshot.mode": "initial",
  // Полный snapshot при первом запуске

  "snapshot.mode": "never",
  // Пропустить snapshot, только streaming

  "snapshot.mode": "schema_only",
  // Только структура таблиц, данные не копируются

  "snapshot.mode": "when_needed"
  // Snapshot если offset не найден
}`}
          relatedLessons={[
            { title: "First Connector", slug: "01-module-1/04-first-connector" },
            { title: "Snapshot Strategies", slug: "02-module-2/05-snapshot-strategies" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Streaming"
          termEn="Потоковая репликация"
          definition="Режим непрерывного чтения изменений из WAL (PostgreSQL) или binlog (MySQL). После завершения snapshot Debezium переключается в streaming mode и читает только новые изменения в реальном времени с минимальной задержкой."
          example={`// Connector status - streaming phase
{
  "name": "inventory-connector",
  "connector": {
    "state": "RUNNING",
    "worker_id": "kafka-connect:8083"
  },
  "tasks": [{
    "id": 0,
    "state": "RUNNING",
    "worker_id": "kafka-connect:8083"
  }],
  "type": "source"
}`}
          relatedLessons={[
            { title: "Streaming Changes", slug: "02-module-2/06-streaming-changes" },
            { title: "Lag Detection", slug: "04-module-4/04-lag-detection-alerting" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Connector"
          termEn="Коннектор Debezium"
          definition="Kafka Connect source connector, который интегрируется с конкретной базой данных (PostgreSQL, MySQL, MongoDB и др.). Коннектор читает изменения через нативные механизмы репликации и публикует события в Kafka."
          example={`# Создание коннектора через REST API
curl -X POST http://localhost:8083/connectors \\
  -H "Content-Type: application/json" \\
  -d @postgres-connector.json

# Проверка статуса
curl http://localhost:8083/connectors/inventory-connector/status

# Удаление коннектора
curl -X DELETE \\
  http://localhost:8083/connectors/inventory-connector`}
          relatedLessons={[
            { title: "First Connector", slug: "01-module-1/04-first-connector" },
            { title: "Connector Configuration", slug: "02-module-2/01-connector-configuration" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="SMT"
          termEn="Single Message Transform"
          definition="Легковесные преобразования Kafka Connect, которые применяются к каждому событию перед записью в Kafka. SMT позволяют фильтровать поля, переименовывать топики, маршрутизировать события без написания отдельного приложения."
          example={`// Connector config - фильтрация полей
{
  "transforms": "unwrap,addPrefix",

  // Debezium Unwrap - извлечь только 'after'
  "transforms.unwrap.type":
    "io.debezium.transforms.ExtractNewRecordState",
  "transforms.unwrap.drop.tombstones": false,

  // Добавить префикс к топику
  "transforms.addPrefix.type":
    "org.apache.kafka.connect.transforms.RegexRouter",
  "transforms.addPrefix.regex": "(.*)",
  "transforms.addPrefix.replacement": "cdc.$1"
}`}
          relatedLessons={[
            { title: "Message Transformations", slug: "05-module-5/04-message-transformations" },
            { title: "Event Routing", slug: "06-module-6/03-event-routing" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Outbox Pattern"
          termEn="Паттерн Outbox"
          definition="Микросервисный паттерн для надёжной публикации событий. При изменении entity приложение также вставляет событие в outbox таблицу в той же транзакции. Debezium читает outbox таблицу и публикует события в Kafka, гарантируя атомарность обновления и публикации."
          example={`-- Outbox таблица
CREATE TABLE outbox (
  id UUID PRIMARY KEY,
  aggregatetype VARCHAR(255) NOT NULL,
  aggregateid VARCHAR(255) NOT NULL,
  type VARCHAR(255) NOT NULL,
  payload JSONB NOT NULL
);

-- Бизнес-логика (атомарная транзакция)
BEGIN;
  UPDATE orders SET status = 'PAID' WHERE id = 123;
  INSERT INTO outbox (id, aggregatetype, aggregateid, type, payload)
  VALUES (gen_random_uuid(), 'Order', '123', 'OrderPaid',
          '{"orderId": 123, "amount": 99.99}'::jsonb);
COMMIT;

// Debezium Outbox SMT
{
  "transforms": "outbox",
  "transforms.outbox.type":
    "io.debezium.transforms.outbox.EventRouter"
}`}
          relatedLessons={[
            { title: "Outbox Pattern", slug: "06-module-6/01-outbox-pattern" },
            { title: "Event Routing", slug: "06-module-6/03-event-routing" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Heartbeat"
          termEn="События heartbeat"
          definition="Периодические события, которые Debezium отправляет в Kafka даже при отсутствии изменений в базе данных. Heartbeat предотвращают удаление binlog/WAL на неактивных таблицах и позволяют отслеживать, что коннектор жив."
          example={`// Connector config - heartbeat каждые 5 минут
{
  "heartbeat.interval.ms": 300000,
  "heartbeat.topics.prefix": "__debezium-heartbeat",

  // Heartbeat событие
  {
    "ts_ms": 1686500577691,
    "source": {
      "connector": "postgresql",
      "name": "dbserver1",
      "lsn": 33023704
    }
  }
}

// Проверка heartbeat топика
kafka-console-consumer \\
  --topic __debezium-heartbeat.dbserver1 \\
  --bootstrap-server localhost:9092`}
          relatedLessons={[
            { title: "Binlog Retention & Heartbeat", slug: "03-module-3/03-binlog-retention-heartbeat" },
            { title: "Lag Detection", slug: "04-module-4/04-lag-detection-alerting" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Tombstone"
          termEn="Tombstone событие"
          definition="Событие Kafka с null значением, которое используется для удаления ключа при log compaction. Debezium отправляет tombstone после DELETE события, чтобы при compaction топика запись была полностью удалена."
          example={`// DELETE события от Debezium

// 1. DELETE событие (op='d')
{
  "before": {"id": 123, "name": "John"},
  "after": null,
  "op": "d"
}

// 2. Tombstone (следует сразу после)
{
  "key": {"id": 123},
  "value": null  // <- tombstone
}

// Connector config - управление tombstones
{
  "transforms": "unwrap",
  "transforms.unwrap.type":
    "io.debezium.transforms.ExtractNewRecordState",
  "transforms.unwrap.drop.tombstones": false
}`}
          relatedLessons={[
            { title: "Event Structure", slug: "05-module-5/01-event-structure" },
            { title: "Topic Configuration", slug: "04-module-4/01-topic-configuration" }
          ]}
          basePath={basePath}
          client:load
        />
      </section>

      <!-- General CDC Section -->
      <section id="general" class="mb-12 scroll-mt-24">
        <h2 class="text-3xl font-bold text-gray-100 mb-6 flex items-center gap-3 border-b border-white/10 pb-3">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8">
            <path stroke-linecap="round" stroke-linejoin="round" d="M12 21v-8.25M15.75 21v-8.25M8.25 21v-8.25M3 9l9-6 9 6m-1.5 12V10.332A48.36 48.36 0 0012 9.75c-2.551 0-5.056.2-7.5.582V21M3 21h18M12 6.75h.008v.008H12V6.75z"/>
          </svg>
          General CDC
        </h2>

        <GlossaryTerm
          term="CDC"
          termEn="Change Data Capture"
          definition="Паттерн захвата изменений данных в реальном времени. Вместо опроса (polling) базы данных, CDC читает журналы транзакций (WAL, binlog) для получения событий INSERT, UPDATE, DELETE с минимальной задержкой и нагрузкой."
          example={`// CDC Event Structure (Debezium JSON)
{
  "before": null,  // Состояние до изменения
  "after": {       // Новое состояние
    "id": 1001,
    "name": "John Doe",
    "email": "john@example.com"
  },
  "source": {
    "version": "2.1.0.Final",
    "connector": "postgresql",
    "name": "dbserver1",
    "ts_ms": 1486500577691,
    "db": "inventory",
    "schema": "public",
    "table": "customers",
    "lsn": 33023704
  },
  "op": "c",  // c=create, u=update, d=delete, r=read
  "ts_ms": 1486500584591
}`}
          relatedLessons={[
            { title: "CDC Fundamentals", slug: "01-module-1/01-cdc-fundamentals" },
            { title: "Event Structure", slug: "05-module-5/01-event-structure" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Schema Registry"
          termEn="Реестр схем"
          definition="Централизованный сервис для хранения и версионирования схем Avro/Protobuf/JSON Schema. При использовании с Debezium позволяет эффективно сериализовать события и обеспечивает совместимость при эволюции схем таблиц."
          example={`# Просмотр зарегистрированных схем
curl http://localhost:8081/subjects

# Получение схемы для топика
curl http://localhost:8081/subjects/\\
dbserver1.inventory.customers-value/versions/latest

# Connector config с Schema Registry
{
  "value.converter": "io.confluent.connect.avro.AvroConverter",
  "value.converter.schema.registry.url":
    "http://schema-registry:8081"
}`}
          relatedLessons={[
            { title: "Schema Evolution", slug: "05-module-5/02-schema-evolution" },
            { title: "Avro Serialization", slug: "05-module-5/03-avro-serialization" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Idempotency"
          termEn="Идемпотентность"
          definition="Свойство операции, при котором повторное применение даёт тот же результат, что и однократное. В CDC критично для обработки дубликатов событий (при retry, rebalance). Consumer должен корректно обрабатывать повторную доставку того же события."
          example={`// НЕ идемпотентная операция
UPDATE accounts SET balance = balance + 100
WHERE id = 123;
// Повторное применение = двойное начисление!

// Идемпотентная операция (event sourcing)
INSERT INTO account_events (account_id, type, amount, event_id)
VALUES (123, 'CREDIT', 100, 'evt-456')
ON CONFLICT (event_id) DO NOTHING;
// Повторное применение = игнорируется

// Debezium + Kafka idempotent producer
{
  "producer.enable.idempotence": true,
  "producer.max.in.flight.requests.per.connection": 5
}`}
          relatedLessons={[
            { title: "Duplicate Handling", slug: "03-module-3/08-duplicate-handling" },
            { title: "Consumer Best Practices", slug: "08-module-8/02-consumer-best-practices" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Exactly-Once"
          termEn="Ровно один раз"
          definition="Гарантия доставки сообщения, при которой каждое событие обрабатывается ровно один раз без потерь и дубликатов. В Kafka достигается через idempotent producer и transactional API. Debezium + Kafka обеспечивают at-least-once, exactly-once требует idempotent consumer."
          example={`// Kafka Streams - exactly-once
Properties props = new Properties();
props.put(StreamsConfig.PROCESSING_GUARANTEE_CONFIG,
  StreamsConfig.EXACTLY_ONCE_V2);

// Debezium config - основа для exactly-once
{
  // Kafka producer идемпотентность
  "producer.enable.idempotence": true,

  // Consumer должен сам обеспечить идемпотентность
  // через deduplication или event_id tracking
}

// Consumer pattern - deduplication
SET processed_events = new Set();
for (event in stream) {
  if (!processed_events.has(event.id)) {
    process(event);
    processed_events.add(event.id);
  }
}`}
          relatedLessons={[
            { title: "Delivery Semantics", slug: "03-module-3/07-delivery-semantics" },
            { title: "Consumer Best Practices", slug: "08-module-8/02-consumer-best-practices" }
          ]}
          basePath={basePath}
          client:load
        />

        <GlossaryTerm
          term="Event Sourcing"
          termEn="Событийное хранение"
          definition="Архитектурный паттерн, где состояние приложения хранится как последовательность событий, а не как текущий snapshot. CDC отлично сочетается с Event Sourcing — изменения базы данных становятся событиями в event log (Kafka), из которых можно восстановить любое состояние системы."
          example={`// Event Store структура
CREATE TABLE event_store (
  event_id UUID PRIMARY KEY,
  aggregate_id VARCHAR(255),
  aggregate_type VARCHAR(255),
  event_type VARCHAR(255),
  event_data JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);

// CDC события как Event Source
{
  "event_id": "evt-123",
  "aggregate_id": "order-456",
  "aggregate_type": "Order",
  "event_type": "OrderPlaced",
  "event_data": {
    "orderId": 456,
    "customerId": 789,
    "amount": 99.99
  }
}

// Восстановление состояния
SELECT * FROM event_store
WHERE aggregate_id = 'order-456'
ORDER BY created_at;`}
          relatedLessons={[
            { title: "Outbox Pattern", slug: "06-module-6/01-outbox-pattern" },
            { title: "Event Structure", slug: "05-module-5/01-event-structure" }
          ]}
          basePath={basePath}
          client:load
        />
      </section>

    </div>

    <!-- Footer Note -->
    <div class="mt-10 glass-panel p-6">
      <p class="text-sm text-gray-400 m-0">
        <strong class="text-gray-300">Не нашли термин?</strong> Используйте Cmd+K для поиска
        по всему курсу или обратитесь к соответствующим урокам модулей для более детальной
        информации. Глоссарий регулярно дополняется новыми терминами.
      </p>
    </div>

  </div>
</BaseLayout>

<style>
  /* Smooth scroll behavior */
  html {
    scroll-behavior: smooth;
  }

  /* Adjust scroll padding for sticky header */
  .scroll-mt-24 {
    scroll-margin-top: 6rem;
  }
</style>
