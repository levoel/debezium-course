---
phase: 16-advanced-topics-recovery
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/content/course/08-module-8/14-multi-connector-deployments.mdx
autonomous: true

must_haves:
  truths:
    - "Learner can deploy multiple MySQL connectors without server.id conflicts"
    - "Learner understands server.id registry pattern and allocation rules"
    - "Learner knows the symptoms and fix for duplicate server.id errors"
    - "Learner can verify active replication connections on MySQL server"
    - "Learner understands shared topic pitfalls (schema history, offsets)"
  artifacts:
    - path: "src/content/course/08-module-8/14-multi-connector-deployments.mdx"
      provides: "Multi-connector deployments lesson with server.id registry"
      min_lines: 400
      contains: ["server.id", "184000", "SHOW SLAVE HOSTS", "registry"]
  key_links:
    - from: "14-multi-connector-deployments.mdx"
      to: "04-mysql-connector-configuration.mdx"
      via: "references database.server.id property"
      pattern: "database.server.id"
    - from: "14-multi-connector-deployments.mdx"
      to: "06-schema-history-recovery.mdx"
      via: "references schema history topic uniqueness"
      pattern: "schema.history.internal.kafka.topic"
---

<objective>
Create multi-connector deployments lesson covering server.id registry management, conflict prevention, and topic isolation patterns

Purpose: Enable learners to safely deploy multiple Debezium connectors to the same MySQL cluster
Output: Lesson 14 in Module 8 with server.id allocation rules, registry template, and verification procedures
</objective>

<execution_context>
@/Users/levoely/.claude/get-shit-done/workflows/execute-plan.md
@/Users/levoely/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-advanced-topics-recovery/16-RESEARCH.md

# Prior phase context
@.planning/phases/13-connector-setup-comparison/13-01-SUMMARY.md

# Existing lessons to reference
@src/content/course/08-module-8/04-mysql-connector-configuration.mdx
@src/content/course/08-module-8/06-schema-history-recovery.mdx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-connector deployments lesson</name>
  <files>src/content/course/08-module-8/14-multi-connector-deployments.mdx</files>
  <action>
Create comprehensive lesson on deploying multiple Debezium MySQL connectors with the following sections:

1. **Introduction** - Why multiple connectors?
   - Different teams/applications need separate CDC streams
   - Different topic naming requirements
   - Different transformation/filtering requirements
   - Isolation for failure domains (one connector failure doesn't affect others)
   - Scaling: parallel snapshots for large databases

2. **The Server ID Problem** (from 16-RESEARCH.md Pitfall 3)
   - MySQL uses server_id to identify replication clients
   - Duplicate server_id = "A slave with the same server_uuid/server_id as this slave has connected"
   - Even stopped connectors hold sessions (timeout delays)
   - Connector won't start until conflict resolves

3. **Server ID Registry Pattern** (from 16-RESEARCH.md Pattern 3)
   - Central tracking of all server.id allocations
   - Range allocation per project: 184000-184999 (avoids MySQL cluster conflicts)
   - Sub-ranges per team: Team A gets 184000-184099, Team B gets 184100-184199
   - Include markdown registry template:
   ```markdown
   # Server ID Registry

   ## Allocation Rules
   - Range: 184000-184999 (Debezium connectors)
   - Increment sequentially
   - Document BEFORE deployment
   - 30-day reuse embargo for decommissioned connectors

   | Connector Name | Server ID | Database | Status | Owner | Date |
   |----------------|-----------|----------|--------|-------|------|
   | orders-cdc     | 184001    | ecommerce | Active | Team A | 2026-01-15 |
   | users-cdc      | 184002    | ecommerce | Active | Team A | 2026-01-15 |
   | inventory-cdc  | 184003    | warehouse | Active | Team B | 2026-01-20 |
   ```

4. **Topic Isolation Rules** (from 16-RESEARCH.md Pitfall 6)
   - Each connector needs UNIQUE:
     * `database.server.name` (affects all topic names)
     * `schema.history.internal.kafka.topic`
     * Offset storage key (automatic via connector name)
   - Shared schema history topic = data corruption (cross-connector DDL pollution)
   - Naming convention: `schema-history.{database.server.name}`

5. **Configuration Examples: Two Connectors to Same MySQL**
   - Connector 1: Orders team
   ```json
   {
     "name": "orders-cdc",
     "config": {
       "database.server.id": "184001",
       "database.server.name": "mysql_orders",
       "table.include.list": "ecommerce.orders,ecommerce.order_items",
       "schema.history.internal.kafka.topic": "schema-history.mysql_orders"
     }
   }
   ```
   - Connector 2: Users team
   ```json
   {
     "name": "users-cdc",
     "config": {
       "database.server.id": "184002",
       "database.server.name": "mysql_users",
       "table.include.list": "ecommerce.users,ecommerce.profiles",
       "schema.history.internal.kafka.topic": "schema-history.mysql_users"
     }
   }
   ```
   - Warning callout: Never share schema.history.internal.kafka.topic between connectors

6. **Verification Procedures** (from 16-RESEARCH.md Code Examples)
   - Check active replication connections on MySQL:
   ```sql
   SHOW SLAVE HOSTS;
   -- Expected: one row per active connector
   ```
   - Check for duplicate server_ids:
   ```sql
   SELECT Server_id, COUNT(*)
   FROM performance_schema.replication_connection_configuration
   GROUP BY Server_id
   HAVING COUNT(*) > 1;
   -- Should return empty (no duplicates)
   ```
   - List all connectors in Kafka Connect:
   ```bash
   curl -s http://localhost:8083/connectors | jq .
   ```

7. **Troubleshooting Server ID Conflicts**
   - Symptom: Connector fails on startup with slave error
   - Diagnosis:
     * Check SHOW SLAVE HOSTS for duplicate
     * Check registry for allocation conflict
     * Check if previous connector session still active (processlist)
   - Resolution:
     * If genuine duplicate: change server.id in config
     * If stale session: wait for timeout or kill connection manually
   - MySQL command to kill stale connection:
   ```sql
   SHOW PROCESSLIST;
   -- Find connection with User='debezium' and old Time
   KILL CONNECTION <id>;
   ```

8. **Scaling Considerations**
   - Resource planning: each connector = 1 MySQL connection + JVM memory
   - Connection limits: check max_connections on MySQL
   - Snapshot parallelism: multiple connectors can snapshot different tables simultaneously
   - Monitoring: each connector exposes separate JMX metrics

9. **Hands-on Exercise: Deploy Two Connectors**
   - Exercise: Deploy orders-cdc and users-cdc to lab MySQL
     * Create registry entry
     * Deploy first connector, verify SHOW SLAVE HOSTS
     * Deploy second connector, verify both appear
     * Verify separate Kafka topics created
     * Verify separate schema history topics
   - Bonus: Intentionally use duplicate server.id, observe error, fix

10. **Summary: Multi-Connector Checklist**
    - Pre-deployment: Allocate server.id in registry, define topic naming
    - During deployment: Verify unique properties, check SHOW SLAVE HOSTS
    - Post-deployment: Monitor each connector separately, maintain registry

Use callout components:
- type="danger": Never share schema history topic between connectors
- type="warning": 30-day reuse embargo on decommissioned server.id values
- type="tip": Use range allocation per team to prevent conflicts
- type="note": server.id range 184000-184999 avoids MySQL cluster conflicts

Include Mermaid diagram:
- Multi-connector topology showing two connectors to same MySQL with separate topics

Follow established patterns:
- Russian text / English code
- Pedagogical structure matching prior Module 8 lessons
- Use Callout component: `import Callout from '../../../components/Callout.tsx'`
- Use Mermaid component: `import { Mermaid } from '../../../components/Mermaid.tsx'`

Frontmatter:
```yaml
title: "Multi-Connector Deployments: Server ID Registry"
description: "Safely deploy multiple Debezium connectors to the same MySQL cluster"
---
```
  </action>
  <verify>
Build passes: `cd "/Users/levoely/debezium course" && npm run build`
File exists with min 400 lines
Contains server.id, 184000, SHOW SLAVE HOSTS, registry keywords
Mermaid diagram renders correctly
  </verify>
  <done>
Lesson 14 created covering server.id registry pattern, topic isolation rules, configuration examples for two connectors, verification procedures, and hands-on exercises
  </done>
</task>

</tasks>

<verification>
1. Lesson file exists at correct path with proper frontmatter
2. Build passes without errors
3. Server.id registry pattern explained with template
4. Topic isolation rules clearly documented
5. Complete configuration examples for two connectors
6. Verification procedures using MySQL commands
7. Hands-on exercise deployable in Docker lab
</verification>

<success_criteria>
- Learner can allocate server.id without conflicts
- Learner understands why schema history topic must be unique per connector
- Configuration examples are copy-paste ready with proper unique values
- Verification procedures allow learner to confirm correct deployment
- Registry template is practical for real-world use
</success_criteria>

<output>
After completion, create `.planning/phases/16-advanced-topics-recovery/16-02-SUMMARY.md`
</output>
