---
phase: 17-multi-database-capstone
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/content/course/07-module-7/04-multi-database-architecture.mdx
autonomous: true

must_haves:
  truths:
    - "Learner understands why multi-database CDC is needed (different teams, legacy systems, data integration)"
    - "Learner can explain two architecture patterns: separate topics vs unified topics"
    - "Learner knows critical operational differences between PostgreSQL and MySQL connectors"
    - "Learner understands trade-offs for each pattern (traceability vs simplicity)"
  artifacts:
    - path: "src/content/course/07-module-7/04-multi-database-architecture.mdx"
      provides: "Multi-database CDC architecture concepts and patterns"
      min_lines: 250
      contains: "ByLogicalTableRouter"
  key_links:
    - from: "04-multi-database-architecture.mdx"
      to: "Module 8 MySQL lessons"
      via: "Cross-references to Phase 12-16 content"
      pattern: "module-8"
    - from: "04-multi-database-architecture.mdx"
      to: "Existing capstone overview"
      via: "Prerequisites reference"
      pattern: "module-7/01-capstone-overview"
---

<objective>
Create the multi-database CDC architecture lesson that explains dual-source CDC concepts, architecture patterns, and operational differences.

Purpose: Extend Module 7 capstone with multi-database foundation concepts. This lesson sets the conceptual groundwork before the configuration lesson.

Output: `src/content/course/07-module-7/04-multi-database-architecture.mdx` (~300-400 lines)
</objective>

<execution_context>
@/Users/levoely/.claude/get-shit-done/workflows/execute-plan.md
@/Users/levoely/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-multi-database-capstone/17-RESEARCH.md

# Existing capstone structure for consistency
@src/content/course/07-module-7/01-capstone-overview.mdx
@src/content/course/07-module-7/02-architecture-deliverables.mdx

# Component imports for consistency
@src/components/Mermaid.tsx
@src/components/Callout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-database architecture lesson structure</name>
  <files>src/content/course/07-module-7/04-multi-database-architecture.mdx</files>
  <action>
Create the lesson file with the following structure:

**Frontmatter:**
```yaml
---
title: "Multi-Database CDC Architecture"
description: "Архитектура CDC pipeline с несколькими источниками: PostgreSQL + MySQL"
order: 4
difficulty: "advanced"
estimatedTime: 35
topics: ["Multi-Database", "CDC", "Architecture", "PostgreSQL", "MySQL"]
prerequisites: ["module-7/01-capstone-overview", "module-8/02-binlog-architecture"]
---
```

**Imports:**
```tsx
import { Mermaid } from '../../../components/Mermaid.tsx';
import Callout from '../../../components/Callout.tsx';
```

**Content sections:**

1. **Introduction** (why multi-database CDC)
   - Real-world scenarios: different teams owning different databases, legacy system integration, polyglot persistence
   - Business driver: unified analytics from heterogeneous sources
   - Reference Module 8 MySQL knowledge as prerequisite

2. **Architecture Patterns** (with Mermaid diagrams)
   - **Pattern 1: Separate Topics Architecture** (recommended for learning)
     - Each database produces to database-specific topics
     - Topic naming: `outbox.event.postgres.{aggregate}`, `outbox.event.mysql.{aggregate}`
     - Pros: clear traceability, independent schema evolution, simpler troubleshooting
     - Cons: consumer handles multiple topics, potential duplicate logic

   - **Pattern 2: Unified Topics Architecture** (advanced)
     - Use ByLogicalTableRouter SMT to consolidate topics
     - Topic naming: `unified.event.{aggregate}` (contains events from both sources)
     - Pros: single consumer, unified processing
     - Cons: key uniqueness complexity, mixed schema evolution, harder isolation

   - Include decision matrix: when to use which pattern

3. **Operational Differences** (PostgreSQL vs MySQL)
   - Table comparing critical differences:
     - Schema history topic: MySQL-only requirement vs PostgreSQL embeds schema in WAL
     - Position tracking: MySQL GTID/binlog position vs PostgreSQL LSN/replication slots
     - Recovery procedures: MySQL schema history backup vs PostgreSQL slot recreation
     - Monitoring metrics: MilliSecondsBehindSource vs WAL lag bytes

   - Use Callout component for critical pitfalls:
     - "Never share schema.history.internal.kafka.topic between MySQL connectors"
     - "Unique database.server.name required to prevent topic conflicts"

4. **Key Links section**
   - Cross-references to Module 8 lessons for MySQL details
   - Cross-references to Module 2 for PostgreSQL details

**Russian text / English code convention applies.**
Use Mermaid diagrams for architecture visualization (at least 2 diagrams).
Use Callout component for warnings and tips.
  </action>
  <verify>
File exists at src/content/course/07-module-7/04-multi-database-architecture.mdx
File contains valid MDX frontmatter with order: 4
File imports Mermaid and Callout components
File contains at least 2 Mermaid diagrams
File contains Callout usage for pitfalls
File references both PostgreSQL (module-2) and MySQL (module-8) content
  </verify>
  <done>
Lesson file created with complete structure covering multi-database CDC architecture patterns and operational differences
  </done>
</task>

<task type="auto">
  <name>Task 2: Add detailed content with diagrams and trade-offs</name>
  <files>src/content/course/07-module-7/04-multi-database-architecture.mdx</files>
  <action>
Complete the lesson with detailed content:

**Mermaid Diagram 1: Separate Topics Architecture**
```
flowchart TB
    subgraph SOURCES["Source Databases"]
        PG["PostgreSQL<br/>outbox table"]
        MY["MySQL<br/>outbox table"]
    end

    subgraph CDC["CDC Layer"]
        PG_CONN["PostgreSQL Connector<br/>database.server.name: postgres_prod"]
        MY_CONN["MySQL Connector<br/>database.server.name: mysql_prod<br/>server.id: 184054"]
    end

    subgraph TOPICS["Kafka Topics (Separate)"]
        PG_TOPIC["outbox.event.postgres.orders"]
        MY_TOPIC["outbox.event.mysql.orders"]
    end

    subgraph CONSUMER["Consumer"]
        PYFLINK["PyFlink<br/>UNION ALL<br/>source_database tracking"]
    end

    PG --> PG_CONN
    MY --> MY_CONN
    PG_CONN --> PG_TOPIC
    MY_CONN --> MY_TOPIC
    PG_TOPIC --> PYFLINK
    MY_TOPIC --> PYFLINK
```

**Mermaid Diagram 2: Unified Topics Architecture**
```
flowchart TB
    subgraph SOURCES["Source Databases"]
        PG["PostgreSQL"]
        MY["MySQL"]
    end

    subgraph CDC["CDC Layer + SMT"]
        PG_CONN["PostgreSQL Connector<br/>+ ByLogicalTableRouter"]
        MY_CONN["MySQL Connector<br/>+ ByLogicalTableRouter"]
    end

    subgraph TOPICS["Kafka Topics (Unified)"]
        UNIFIED["unified.event.orders<br/>(both sources)"]
    end

    PG --> PG_CONN
    MY --> MY_CONN
    PG_CONN --> UNIFIED
    MY_CONN --> UNIFIED
```

**Comparison Table:**
| Aspect | Separate Topics | Unified Topics |
|--------|-----------------|----------------|
| Topic count | 2N (N per database) | N (consolidated) |
| Consumer complexity | Multiple sources | Single source |
| Schema evolution | Independent | Coordinated |
| Troubleshooting | Easier (source isolation) | Harder (mixed events) |
| Key uniqueness | Natural (separate streams) | Requires handling |
| Recommended for | Learning, different schemas | Identical schemas |

**Operational Differences Table:**
| Aspect | PostgreSQL | MySQL |
|--------|------------|-------|
| Schema storage | Embedded in WAL events | Separate schema history topic |
| Position tracking | LSN + replication slot | GTID or binlog file:position |
| Recovery from position loss | Recreate slot + resnapshot | Backup schema history + resnapshot |
| Heartbeat purpose | Advance slot (prevent WAL bloat) | Advance position (prevent purge) |
| Unique identifier | slot.name | database.server.id |

**Pitfalls section with Callouts:**
- Shared schema history topic corruption
- Topic naming conflicts (duplicate database.server.name)
- Ignoring envelope format differences
- Assuming identical recovery procedures

**Cross-references:**
- Link to Module 8 lessons for MySQL-specific details
- Link to Module 2 for PostgreSQL replication concepts
- Link to next lesson (05-multi-database-configuration) for implementation

Ensure lesson follows existing capstone style (02-architecture-deliverables.mdx as reference).
  </action>
  <verify>
File contains comparison table for patterns
File contains operational differences table
File contains at least 2 Callout components for pitfalls
File is at least 250 lines
Run: npm run build (should pass with no MDX errors)
  </verify>
  <done>
Complete multi-database architecture lesson with diagrams, tables, trade-offs analysis, and cross-references to prior course content
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. File exists: src/content/course/07-module-7/04-multi-database-architecture.mdx
2. Frontmatter valid with order: 4 and correct prerequisites
3. Contains Mermaid and Callout imports
4. Contains at least 2 architecture diagrams
5. Contains comparison tables for patterns and operational differences
6. Contains Callout warnings for critical pitfalls
7. Cross-references to Module 2 (PostgreSQL) and Module 8 (MySQL)
8. Build passes: `npm run build`
</verification>

<success_criteria>
- Learner reading this lesson understands WHY multi-database CDC exists
- Learner can distinguish between separate topics and unified topics patterns
- Learner knows the critical operational differences (schema history, position tracking)
- Learner knows to avoid common pitfalls (shared schema history, topic naming conflicts)
- Content integrates with existing capstone flow (overview -> architecture -> this lesson -> configuration)
</success_criteria>

<output>
After completion, create `.planning/phases/17-multi-database-capstone/17-01-SUMMARY.md`
</output>
